# Основы Stream API
Stream API не предлагает решения для всех возможных сценариев обработки данных. Однако, большинство задач могут быть описаны следующим общим шаблоном:

1. Источник данных.
2. Выполнение преобразований.
3. Сохранение результата в новую структуру данных.

### Основные свойства потоков:

* Декларативность: Потоки в Java описывают, что должно быть сделано, а не конкретный способ его выполнения.
* Ленивость: Это означает, что потоки не выполняют никакой работы, пока не будет вызвана терминальная операция.
* Одноразовость: После того как терминальная операция была вызвана на потоке, этот поток больше не может быть использован. Если необходимо применить другую операцию к данным, потребуется новый поток.
* Параллельность: Несмотря на то, что потоки в Java по умолчанию выполняются последовательно, их можно легко распараллелить.

### Компоненты Stream API
Stream API состоит из набора компонентов и концепций, которые работают вместе, чтобы обеспечить потоковую обработку данных.

* Источник (Source) - откуда приходят данные. Это может быть коллекция, массив, файл, генератор или любой другой источник данных.
* Операции - преобразовывают и/или обрабатывают данные(промежуточные и терминальные).
* Поток (Stream) - последовательность элементов, подлежащих параллельной или последовательной обработке.
* Пайплайн (Pipeline) - последовательность операций в потоке, применяемых к данным.
* Терминал (Terminal) - место выхода данных из потока. Терминальная операция означает окончание обработки потока и возвращает результат.

# Промежуточные операции
Промежуточные операции в потоках Java описываются декларативно с использованием лямбда-выражений. Эти операции представляют собой своего рода "рецепт" обработки данных.
Однако стоит учесть, что они не выполняются немедленно после объявления. В действительности, все промежуточные операции выполняются только при вызове терминальной операции, которая запускает общую цепочку обработки.
Важной характеристикой промежуточных операций является то, что каждая из них возвращает новый объект Stream. Это позволяет нам связывать несколько операций в одну "цепочку" (Pipeline).

# Терминальные операции
Терминальные операции выводят конечный результат обработки потока. Они могут включать в себя перебор элементов, подсчет элементов, сбор элементов в коллекцию, поиск элементов и т.д.
Именно терминальная операция запускает поток. После ее вызова происходит анализ операций в пайплайне, и определяется эффективная стратегия его выполнения.
После вызова терминальной операции тот же поток использовать повторно нельзя. Попытка реализовать "наследование" пайплайнов не увенчается успехом. 

# Stateless и Statefull операции
Операции без состояния (stateless), такие как map() и filter(), обрабатывают каждый элемент потока независимо от других. Они не требуют информации о других элементах для своей работы, что делает их идеально подходящими для параллельной обработки.
С другой стороны, операции, сохраняющие состояние (stateful), такие как sorted(), distinct() или limit(), требуют знания о других элементах для своей работы. Это означает, что им приходится учитывать все (или часть) элементы в потоке перед выдачей какого-либо результата.
Если ваш пайплайн содержит только операции без состояния, то он может быть обработан "в один проход". Если же он содержит операции с состоянием, то пайплайн разбивается на секции, где каждая секция заканчивается операцией с состоянием.

# Spliterator
Spliterator используется в основе стримов в Java и играет важную роль при параллельной обработке данных, так как именно он отвечает за разделение данных на части для независимой обработки каждым потоком.

### Методы Spliterator
Spliterator описывает 4 основных метода:

long estimateSize() возвращает количество элементов.
tryAdvance(Consumer) принимает функциональный интерфейс Consumer, который определяет действия, которые должны быть выполнены над текущим элементом.
int characteristics() возвращает набор характеристик текущего сплитератора.
Spliterator<T> trySplit() пытается разделить текущий сплитератор на два. Если операция успешна, то возвращает новый сплитератор, и уменьшает размер исходного сплитератора. Если разделение не возможно, то возвращает null.

### Характеристики Spliterator
Spliterator обладает специальными характеристиками, которые сообщают об особенностях источника данных, из которого он был создан. Эти характеристики помогают в оптимизации работы потока при выполнении терминальных операций. Например, нет смысла выполнять сортировку уже отсортированной коллекции.

ORDERED: указывает, что элементы имеют определенный порядок.
DISTINCT: указывает, что каждый элемент уникален. Определяется по equals().
SORTED: указывает, что элементы отсортированы.
SIZED: указывает, что размер источника известен заранее.
NONNULL: указывает, что ни один элемент не может быть null.
IMMUTABLE: указывает, что элементы не могут быть модифицированы.
CONCURRENT: указывает, что исходные данные могут быть модифицированы без воздействия на Spliterator.
SUBSIZED: указывает, что размер разделенных Spliterator-ов также будет известен.

# Параллельное выполнение
Stream API предоставляет возможность параллельной обработки данных, что может способствовать увеличению производительности на многоядерных процессорах. Однако необходимо учитывать, что параллельное выполнение может внести дополнительную сложность и накладные расходы, поэтому следует использовать его обдуманно.

Для выполнения потоков в параллельном режиме можно использовать методы parallelStream() или parallel(). Без явного вызова этих методов поток будет выполняться последовательно. Для разделения коллекции на части, которые могут быть обработаны отдельными потоками, Java использует метод Spliterator.trySplit().

С точки зрения плана выполнения, параллельная обработка схожа с последовательной, за исключением одного основного отличия. Вместо одного набора связанных операций у нас будет несколько его копий, и каждый поток будет применять эти операции к своему сегменту элементов. После завершения обработки все результаты, полученные каждым потоком, объединяются в один общий результат.
